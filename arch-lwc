#!/usr/bin/env bash

# Create and run lightweight containers
#
# Copyright (C) 2021 Maddison Hellstrom <https://github.com/b0o>, MIT License.

set -euo pipefail
if [[ ${BASH_VERSINFO[0]} -ge 5 || (${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -ge 4) ]]; then
  shopt -s inherit_errexit
fi

declare -g base
declare -g prog
base="$(realpath -e "${BASH_SOURCE[0]}")"
prog="$(basename "$base")"

declare -g version="0.0.2"
declare -g authors=("2021 Maddison Hellstrom <github.com/b0o>")
declare -g repository="https://github.com/b0o/$prog"
declare -g issues="https://github.com/b0o/$prog/issues"
declare -g license="MIT"
declare -g license_url="https://mit-license.org"

declare -ga deps=("pacstrap" "systemd-nspawn" "systemd-run")

declare -ga default_pkgs=("base" "pacman-contrib")
declare -g default_groups="tty,wheel,video,input"

declare -g tmp=""
declare -g ephemeral_mount=""
declare -g ephemeral_directory=""

function usage() {
  cat << EOF
Usage: $prog [opts] CONTAINER

Create and run lightweight Arch Linux containers with pacstrap and systemd.

Options
  General
  -h        show help
  -v        show version
  -i        enable interactive mode

  Container Creation
  -p PKG         Append package to list of packages to be installed. May be
                 specified more than once. (default: ${default_pkgs[*]})

  -P PKG         Like -p, but override default packages.

  -u USER        Name of target user inside the container. If the user doesn't
                 exist, it will created. to create inside container. Any
                 commands specified with -x will run as this user from the
                 user's home directory. If not specified, the root user will be
                 used. (default: root)

  -g GRP[,GRP..] Add the user to these groups in addition to the default
                 groups. (default: $default_groups)

  -G GRP[,GRP..] Like -g, but override default groups. Use -G "" to prevent
                 adding the user to any groups.

  -T             Don't disable securetty (this will likely prevent $prog from
                 running the container and prevent you from obtaining a shell
                 in the container).

  -f SRC[:DST]   Copy the file SRC from the host machine to DST in the container.
                 If DST is omitted, it will be inferred as SRC's absolute path.

  -t             Create the container inside an ephemeral tmpfs device.
                 The device will be unmounted (and the data lost) after $prog
                 exits.
                 (warning: not guaranteed to leave no trace)

  -r             Like -t, but use a ramfs device.
                 (warning: data size may exceed available RAM and cause system
                 instability)
                 (warning: not guaranteed to leave no trace)

  Container Runtime
  -n NSPAWNARG   When running the container, pass NSPAWNARG as a command-line
                 argument to systemd-nspawn. May be specified more than once.
                 Arguments with values, such as for systemd-nspawn's -E /
                 --setenv option, should be passed either as a single -n with
                 no spaces (e.g. -n "--setenv=VAR=VAL") or as two sequential -n
                 arguments (e.g. -n "-E" -n "VAR=VAL").

                 See systemd-nspawn(1) for more information on systemd-nspawn
                 arguments. Note that certain systemd-nspawn arguments may conflict
                 with the behavior of $prog, such as --boot.

                 For example, -n "--bind=/etc".

                 For convenience, the following systemd-nspawn options have $prog aliases:
                   $prog opt    systemd-nspawn opt
                   -b ARG ${prog//?/ } --bind=ARG
                   -B ARG ${prog//?/ } --bind-ro=ARG
                   -e ARG ${prog//?/ } --setenv=ARG

  -x CMD         Run CMD inside the container after setup is complete. CMD will
                 be interpreted by bash and can contain multiple statements
                 separated by semicolons and/or newlines.

About
  Version:    $version
  Repository: $repository
  Issues:     $issues
  License:    $license ($license_url)
  Copyright:  ${authors[0]}
EOF
  if [[ ${#authors[@]} -gt 1 ]]; then
    printf '              %s\n' "${authors[@]:1}"
  fi
}

function cleanup() {
  if [[ -n "$ephemeral_mount" ]]; then
    umount -v "$ephemeral_mount"
    if [[ -n "$ephemeral_directory" ]]; then
      rmdir -v "$ephemeral_directory"
    fi
  fi
  if [[ -n "$tmp" && -d "$tmp" && "$(realpath -m "$tmp")" != "/" ]]; then
    rm --preserve-root --one-file-system -r "$tmp"
  fi
}

function main() {
  local -a pkgs_base=("${default_pkgs[@]}")
  local -a pkgs=()
  local user="root"
  local groups_base="$default_groups"
  local groups=""
  local -i interactive=0
  local -i securetty=0
  local -a files=()
  local -a cmds=()
  local fstype=""
  local -a nspawn_args=()

  local opt OPTARG
  local -i OPTIND
  while getopts ":hvip:P:u:g:G:Tf:n:b:B:e:x:tr" opt "$@"; do
    case "$opt" in
    h)
      usage
      return 0
      ;;
    v)
      echo "$version"
      return 0
      ;;
    i)
      interactive=1
      ;;
    p)
      pkgs+=("$OPTARG")
      ;;
    P)
      pkgs_base=()
      pkgs+=("$OPTARG")
      ;;
    u)
      user="$OPTARG"
      ;;
    g)
      groups+=",$OPTARG"
      ;;
    G)
      groups_base=""
      groups+=",$OPTARG"
      ;;
    T)
      securetty=1
      ;;
    f)
      local src dest
      src="$(cut -d':' -f1 <<< "$OPTARG")"
      dest="$(cut -sd':' -f2 <<< "$OPTARG")"
      dest="${dest:-$src}"
      if [[ -z "$src" ]]; then
        echo "$prog: error: invalid option -- -f $OPTARG" >&2
        return 1
      fi
      src="$(realpath -e "$src")"
      dest="/$(realpath -m --relative-to="/" "/$dest" | sed -E 's|^(\.\./)*||g; s|\.\.||')"
      files+=("$src" "$dest")
      ;;
    n)
      nspawn_args+=("$OPTARG")
      ;;
    b)
      nspawn_args+=("--bind=$OPTARG")
      ;;
    B)
      nspawn_args+=("--bind-ro=$OPTARG")
      ;;
    e)
      nspawn_args+=("--setenv=$OPTARG")
      ;;
    x)
      cmds+=("$OPTARG")
      ;;
    t)
      fstype="tmpfs"
      ;;
    r)
      fstype="ramfs"
      ;;
    *)
      echo "$prog: error: invalid option -- -$OPTARG" >&2
      return 1
      ;;
    esac
  done
  shift $((OPTIND - 1))

  if [[ $# -lt 1 ]]; then
    echo "$prog: error: expected PATH to container" >&2
    return 1
  fi

  local container
  container="$(realpath -m "$1")"
  shift

  if [[ $# -gt 1 ]]; then
    echo "$prog: error: unexpected argument(s): $*" >&2
    return 1
  fi

  if [[ $UID -ne 0 ]]; then
    echo "$prog: error: must be run as root" >&2
    return 1
  fi

  local dep
  for dep in "${deps[@]}"; do
    command -v "$dep" 2> /dev/null >&2 || {
      echo "$prog: error: dependency not found: $dep" >&2
      return 1
    }
  done

  tmp="$(mktemp -td "$prog-XXXXX")"
  trap "cleanup" EXIT

  pkgs=("${pkgs_base[@]}" "${pkgs[@]}")
  groups="${groups_base:+${groups_base}${groups:+,}}${groups}"

  local pacstrap_opts=(-G)
  if [[ $interactive -eq 1 ]]; then
    pacstrap_opts+=(-i)
  fi

  if [[ ! -d "$container" && -e "$container" ]]; then
    echo "error: PATH exists and is not an empty directory: $container" >&2
    return 1
  fi
  if [[ -d "$container" ]]; then
    if [[ -n "$(ls -A "$container")" ]]; then
      echo "error: PATH is a non-empty directory: $container" >&2
      return 1
    fi
  else
    mkdir -p "$container"
    ephemeral_directory="$container"
  fi
  if [[ -n "$fstype" ]]; then
    mount -t "$fstype" "$(basename "$container")-$fstype" "$container"
    ephemeral_mount="$container"
  fi

  pacstrap "${pacstrap_opts[@]}" "$container" "${pkgs[@]}"

  if [[ $securetty -eq 0 ]]; then
    echo "Remove securetty configuration" >&2
    rm "$container/etc/securetty" "$container/usr/share/factory/etc/securetty"
    sh -c "echo 'NoExtract = /etc/securetty /usr/share/factory/etc/securetty' >> '$container/etc/pacman.conf'"
  fi

  local -a files_tmp=()
  if [[ ${#files[@]} -gt 0 ]]; then
    mkdir "$tmp/copy"
    nspawn_args+=("--bind-ro=$tmp/copy")
    local -i i=0
    local src dest
    while ((i < ${#files[@]})); do
      src="${files[i]}"
      dest="$(realpath -m "$container/${files[$((i + 1))]}")"
      dest_tmp="$(realpath -m "$tmp/copy/${files[$((i + 1))]}")"
      files_tmp+=("$dest_tmp")
      i=$((i + 2))

      local -a cp_opts=()
      if [[ -d "$src" ]]; then
        cp_opts+=(-r)
      fi

      echo "Copy $src -> $dest" >&2
      mkdir -p "$(dirname "$dest_tmp")"
      cp "${cp_opts[@]}" "$src" "$dest_tmp"
    done
  fi

  if [[ ${#cmds[@]} -gt 0 ]]; then
    mkdir "$tmp/cmds"
    local cmd
    local -i i=1
    for cmd in "${cmds[@]}"; do
      local c="$tmp/cmds/$i"
      echo "Prepare cmd $c"
      {
        echo "set -x"
        echo "$cmd"
      } > "$c"
      chmod a+rx "$c"
      i=$((i + 1))
    done
  fi

  {
    cat << EOF
      #!/usr/bin/env bash
      set -x
      if ! getent passwd "$user" 2>/dev/null >&2; then
        useradd -U -s /usr/bin/bash -d "/home/$user" "$user"
        mkdir "/home/$user"
        chown "$user:$user" "/home/$user"
      fi
EOF
    if [[ -n "$groups" ]]; then
      echo "usermod -aG \"$groups\" \"$user\""
    fi
    if [[ ${#files_tmp[@]} -gt 0 ]]; then
      local f
      for f in "${files_tmp[@]}"; do
        echo "install -D \"$f\" \"/$(realpath -m --relative-base="$tmp/copy" "$f")\""
      done
    fi
    local i
    echo "echo \"Setup complete\""
    for i in $(seq 1 ${#cmds[@]}); do
      echo "echo \"Run command $i\""
      if [[ "$user" == "root" ]]; then
        echo "cat /tmp/container/cmds/$i | env -C /root bash"
      else
        echo "cp /tmp/container/cmds/$i /tmp/cmd"
        echo "chown \"$user:$user\" /tmp/cmd"
        echo "chmod +x /tmp/cmd"
        # shellcheck disable=SC2028
        echo "su -w \"\$(env | cut -d'=' -f1 | tr '\n' ',' | sed 's/,\$//')\" -lc 'cat /tmp/cmd | bash' \"$user\""
        echo "rm /tmp/cmd"
      fi
    done
    if [[ $interactive -eq 1 ]]; then
      echo "read -n1 -p \"Complete. Press any key to continue...\""
    fi
  } > "$tmp/main.sh"

  systemd-nspawn -D "$container" --bind-ro="$tmp:/tmp/container" "${nspawn_args[@]}" sh /tmp/container/main.sh
}

main "$@"
